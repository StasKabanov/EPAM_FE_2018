1) Каким будет результат? Почему?

var arr = ["a", "b"];

arr.push(function() {
  alert( this );
})

arr[2](); // ?

### Выведется массив, "a","b",function



2) Каков будет результат этого кода?

var obj = {
  go: function() { alert(this) }
}

(obj.go)()

### Будет ошибка, т.к. пропущена ";"



3) Вызовы (1) и (2) в примере ниже работают не так, как (3) и (4):

"use strict"

var obj, method;

obj = {
  go: function() { alert(this); }
};

obj.go();            // (1) object

(obj.go)();          // (2) object

(method = obj.go)();      // (3) undefined

(obj.go || obj.stop)(); // (4) undefined

В чём дело? Объясните логику работы this.

###
(1)Обычный вызов функции в контексте объекта.

(2)То же самое, скобки ни на что не влияют.

(3)Здесь не просто вызов obj.method(), а более сложный вызов вида (выражение).method(). Такой вызов работает, как если бы он был разбит на две строки:

f = obj.go; // сначала вычислить выражение
f();             // потом вызвать то, что получилось

(4)Здесь также слева от точки находится выражение, вызов аналогичен двум строкам.


4) Что выведет alert в этом коде? Почему?

var user = {
  firstName: "Василий",

  export: this
};

alert( user.export.firstName );


### вернется нам undefined, т.к. код находится вообще вне любых функций, то this в нём равен window.


5)Что выведет alert в этом коде? Почему?

var name = "";

var user = {
  name: "Василий",

  export: function() {
    return this;
  }

};

alert( user.export().name );

### Ответ: Василий. Вызов user.export() использует this, который равен объекту до точки, то есть внутри user.export() строка return this возвращает объект user.

6) Что выведет alert в этом коде? Почему?

var name = "";

var user = {
  name: "Василий",

  export: function() {
    return {
      value: this
    };
  }

};

alert( user.export().value.name );

### Ответ: Василий. Во время выполнения user.export() значение this = user.

При создании объекта { value: this }, в свойство value копируется ссылка на текущий контекст, то есть на user.

7) Создайте объект calculator с тремя методами:

    read() запрашивает prompt два значения и сохраняет их как свойства объекта
    sum() возвращает сумму этих двух значений
    mul() возвращает произведение этих двух значений

###
var calculator = {
  sum: function() {
    return this.a + this.b;
  },

  mul: function() {
    return this.a * this.b;
  },

  read: function() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  }
}

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );

8)Есть объект «лестница» ladder:

var ladder = {
  step: 0,
  up: function() { // вверх по лестнице
    this.step++;
  },
  down: function() { // вниз по лестнице
    this.step--;
  },
  showStep: function() { // вывести текущую ступеньку
    alert( this.step );
  }
};

Сейчас, если нужно последовательно вызвать несколько методов объекта, это можно сделать так:

ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1

Модифицируйте код методов объекта, чтобы вызовы можно было делать цепочкой, вот так:

ladder.up().up().down().up().down().showStep(); // 1

### 
var ladder = {
  step: 0,
  up: function() {
    this.step++;
    return this;
  },
  down: function() {
    this.step--;
    return this;
  },
  showStep: function() {
    alert( this.step );
    return this;
  }
}

ladder.up().up().down().up().down().showStep(); // 1
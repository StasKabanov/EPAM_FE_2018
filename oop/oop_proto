1) Какие значения будут выводиться в коде ниже?

var animal = {
  jumps: null
};
var rabbit = {
  jumps: true
};

rabbit.__proto__ = animal;

alert( rabbit.jumps ); // ? (1)

delete rabbit.jumps;

alert( rabbit.jumps ); // ? (2)

delete animal.jumps;

alert( rabbit.jumps ); // ? (3)

### Решение:

    1.true, свойство взято из rabbit.
    2.null, свойство взято из animal.
    3.undefined, свойства больше нет.

2) Сработает ли вызов rabbit.eat() ?

Если да, то в какой именно объект он запишет свойство full: в rabbit или animal?

var animal = {
  eat: function() {
    this.full = true;
  }
};

var rabbit = {
  __proto__: animal
};

rabbit.eat();

### Решение:

Свойство будет записано в rabbit,потому что this будет указывать на rabbit.

3) Есть объекты:

var head = {
  glasses: 1
};

var table = {
  pen: 3
};

var bed = {
  sheet: 1,
  pillow: 2
};

var pockets = {
  money: 2000
};

 Задание состоит из двух частей:

    1.Присвойте объектам ссылки __proto__ так, чтобы любой поиск чего-либо шёл по алгоритму pockets -> bed -> table -> head.

    То есть pockets.pen == 3, bed.glasses == 1, но table.money == undefined.

    2.После этого ответьте на вопрос, как быстрее искать glasses: обращением к pockets.glasses или head.glasses? Попробуйте протестировать.

### Решение:

var head = {
  glasses: 1
};

var table = {
  pen: 3
};
table.__proto__ = head;

var bed = {
  sheet: 1,
  pillow: 2
};
bed.__proto__ = table;

var pockets = {
  money: 2000
};
pockets.__proto__ = bed;

alert( pockets.pen ); // 3
alert( bed.glasses ); // 1
alert( table.money ); // undefined

В современных браузерах, с точки зрения производительности, нет разницы,
брать свойство из объекта или прототипа. Они запоминают, где было найдено свойство и в следующий раз при запросе.

4) В примерах ниже создаётся объект new Rabbit,
а затем проводятся различные действия с prototype.

Каковы будут результаты выполнения? Почему?

Начнём с этого кода. Что он выведет?


function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

var rabbit = new Rabbit();

alert( rabbit.eats );

### Решение: true, из прототипа


function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

var rabbit = new Rabbit();

Rabbit.prototype = {};

alert( rabbit.eats );

А если код будет такой? (заменена одна строка):


### Решение:

true. Свойство prototype всего лишь задаёт __proto__ у новых объектов,
так что его изменение не повлияет на rabbit.__proto__. Свойство eats будет получено из прототипа.




function Rabbit(name) {}
Rabbit.prototype = {
  eats: true
};

var rabbit = new Rabbit();

Rabbit.prototype.eats = false;

alert( rabbit.eats );

### Решение:

false. Свойство Rabbit.prototype и rabbit.__proto__ указывают на один и тот же объект.
В данном случае изменения вносятся в сам объект.



function Rabbit(name) {}
Rabbit.prototype = {
  eats: true
};

var rabbit = new Rabbit();

delete rabbit.eats; // (*)

alert( rabbit.eats );


### Решение:
true, так как delete rabbit.eats попытается удалить eats из rabbit, где его и так нет.
А чтение в alert произойдёт из прототипа.


function Rabbit(name) {}
Rabbit.prototype = {
  eats: true
};

var rabbit = new Rabbit();

delete Rabbit.prototype.eats; // (*)

alert( rabbit.eats );

### Решение:

undefined. Удаление осуществляется из самого прототипа,
поэтому свойство rabbit.eats больше взять неоткуда.


5) Есть функция Menu, которая получает аргументы в виде объекта options:

/* options содержит настройки меню: width, height и т.п. */
function Menu(options) {
  ...
}

Ряд опций должны иметь значение по умолчанию. Мы могли бы проставить их напрямую в объекте options:

function Menu(options) {
  options.width = options.width || 300; // по умолчанию ширина 300
  ...
}

…Но такие изменения могут привести к непредвиденным результатам, т.к. объект options может быть повторно использован во внешнем коде. Он передается в Menu для того, чтобы параметры из него читали, а не писали.

При помощи наследования и Object.create предложите третий способ, который позволяет избежать копирования объекта и не требует новых переменных.


### Решение:

Можно прототипно унаследовать от options и добавлять/менять опции в наследнике:

function Menu(options) {
  options = Object.create(options);
  options.width = 300;

  alert("width: " + options.width); // возьмёт width из наследника
  alert("height: " + options.height); // возьмёт height из исходного объекта
}

var options = {
  width: 100,
  height: 200
};

var menu = new Menu(options);

6) Есть ли разница между вызовами?

Создадим новый объект, вот такой:

function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function() {
  alert( this.name );
};

var rabbit = new Rabbit("Rabbit");

Одинаково ли сработают эти вызовы?

rabbit.sayHi();
Rabbit.prototype.sayHi();
Object.getPrototypeOf(rabbit).sayHi();
rabbit.__proto__.sayHi();

Все ли они являются кросс-браузерными? Если нет – в каких браузерах сработает каждый?

### Решение:

Первый вызов ставит this == rabbit, остальные ставят this равным Rabbit.prototype.

Так что только первый вызов выведет Rabbit, в остальных он будет undefined.

Совместимость

    1.Первый вызов работает везде.
    2.Второй вызов работает везде.
    3.Третий вызов не будет работать в IE8-, там нет метода getPrototypeOf
    4.Четвёртый вызов – самый «несовместимый», он не будет работать в IE10-, ввиду отсутствия свойства __proto__.

7) Пусть у нас есть произвольный объект obj, созданный каким-то конструктором, каким – мы не знаем, но хотели бы создать новый объект с его помощью.

Сможем ли мы сделать так?

var obj2 = new obj.constructor();


### Решение:

Да, можем, но только если уверены, что кто-то позаботился о том,
чтобы значение constructor было верным.

Например,

function User(name) {
  this.name = name;
}

var obj = new User('Вася');
var obj2 = new obj.constructor('Петя');

alert( obj2.name ); // Петя (сработало)

Сработало, так как User.prototype.constructor == User.

8) Добавьте всем функциям в прототип метод defer(ms), который откладывает вызов функции на ms миллисекунд.

### Решение:

Function.prototype.defer = function(ms) {
  setTimeout(this, ms);
}

function f() {
  alert( "привет" );
}

f.defer(1000); // выведет "привет" через 1 секунду

9) Добавьте всем функциям в прототип метод defer(ms), который возвращает обёртку, откладывающую вызов функции на ms миллисекунд.

Например, должно работать так:

function f(a, b) {
  alert( a + b );
}

f.defer(1000)(1, 2); // выведет 3 через 1 секунду.

### Решение:

Function.prototype.defer = function(ms) {
  var f = this;
  return function() {
    var args = arguments,
      context = this;
    setTimeout(function() {
      f.apply(context, args);
    }, ms);
  }
}

// проверка
function f(a, b) {
  alert( a + b );
}

f.defer(1000)(1, 2); // выведет 3 через 1 секунду.

10) Есть класс CoffeeMachine, заданный в функциональном стиле.

Задача: переписать CoffeeMachine в виде класса с использованием прототипа.


### Решение:

function CoffeeMachine(power) {
  // свойства конкретной кофеварки
  this._power = power;
  this._waterAmount = 0;
}

// свойства и методы для всех объектов класса
CoffeeMachine.prototype.WATER_HEAT_CAPACITY = 4200;

CoffeeMachine.prototype._getTimeToBoil = function() {
  return this._waterAmount * this.WATER_HEAT_CAPACITY * 80 / this._power;
};

CoffeeMachine.prototype.run = function() {
  setTimeout(function() {
    alert( 'Кофе готов!' );
  }, this._getTimeToBoil());
};

CoffeeMachine.prototype.setWaterAmount = function(amount) {
  this._waterAmount = amount;
};

var coffeeMachine = new CoffeeMachine(10000);
coffeeMachine.setWaterAmount(50);
coffeeMachine.run();

11) Вы – руководитель команды, которая разрабатывает игру, хомяковую ферму. Один из программистов получил задание создать класс «хомяк» (англ – "Hamster").

Объекты-хомяки должны иметь массив food для хранения еды и метод found для добавления.

Ниже – его решение. При создании двух хомяков, если поел один – почему-то сытым становится и второй тоже.

В чём дело? Как поправить?

function Hamster() {}

Hamster.prototype.food = []; // пустой "живот"

Hamster.prototype.found = function(something) {
  this.food.push(something);
};

// Создаём двух хомяков и кормим первого
var speedy = new Hamster();
var lazy = new Hamster();

speedy.found("яблоко");
speedy.found("орех");

alert( speedy.food.length ); // 2
alert( lazy.food.length ); // 2 (!??)


### Решение:

свойство food изменяется в прототипе, который является общим для всех объектов-хомяков.

Для исправления проблемы нужно дать каждому хомяку свой живот. Это можно сделать, присвоив его в конструкторе.

function Hamster() {
  this.food = [];
}

Hamster.prototype.found = function(something) {
  this.food.push(something);
};

var speedy = new Hamster();
var lazy = new Hamster();

speedy.found("яблоко");
speedy.found("орех");

alert(speedy.food.length) // 2
alert(lazy.food.length) // 0(!)


12) Найдите ошибку в прототипном наследовании. К чему она приведёт?

function Animal(name) {
  this.name = name;
}

Animal.prototype.walk = function() {
  alert( "ходит " + this.name );
};

function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype = Animal.prototype;

Rabbit.prototype.walk = function() {
  alert( "прыгает! и ходит: " + this.name );
};

### Решение:

Ошибка в строке:

Rabbit.prototype = Animal.prototype;

Эта ошибка приведёт к тому, что Rabbit.prototype и Animal.prototype – один и тот же объект. В результате методы Rabbit будут помещены в него и, при совпадении, перезапишут методы Animal.
Правильный вариант этой строки:
Rabbit.prototype = Object.create(Animal.prototype);

13)Найдите ошибку в прототипном наследовании. К чему она приведёт?

function Animal(name) {
  this.name = name;

  this.walk = function() {
    alert( "ходит " + this.name );
  };

}

function Rabbit(name) {
  Animal.apply(this, arguments);
}
Rabbit.prototype = Object.create(Animal.prototype);

Rabbit.prototype.walk = function() {
  alert( "прыгает " + this.name );
};

var rabbit = new Rabbit("Кроль");
rabbit.walk();

### Решение:

Ошибка – в том, что метод walk присваивается в конструкторе Animal самому объекту вместо прототипа.
Метод this.walk из Animal записывается в сам объект, и поэтому он всегда будет первым, игнорируя цепочку прототипов.


14) Задача: переписать часы на прототипах. Приватные свойства и методы сделать защищёнными.

### Решение:

function Clock(options) {
  this._template = options.template;
}

Clock.prototype._render = function() {
  var date = new Date();

  var hours = date.getHours();
  if (hours < 10) hours = '0' + hours;

  var min = date.getMinutes();
  if (min < 10) min = '0' + min;

  var sec = date.getSeconds();
  if (sec < 10) sec = '0' + sec;

  var output = this._template.replace('h', hours).replace('m', min).replace('s', sec);

  console.log(output);
};

Clock.prototype.stop = function() {
  clearInterval(this._timer);
};

Clock.prototype.start = function() {
  this._render();
  var self = this;
  this._timer = setInterval(function() {
    self._render();
  }, 1000);
};

15) Есть реализация часиков на прототипах. Создайте класс, расширяющий её, добавляющий поддержку параметра precision, который будет задавать частоту тика в setInterval. Значение по умолчанию: 1000.


### Решение:

function ExtendedClock(options) {
  Clock.apply(this, arguments);
  this._precision = +options.precision || 1000;
}

ExtendedClock.prototype = Object.create(Clock.prototype);

ExtendedClock.prototype.start = function() {
  this._render();
  var self = this;
  this._timer = setInterval(function() {
    self._render();
  }, this._precision);
};

16) 
Есть класс Menu. У него может быть два состояния: открыто STATE_OPEN и закрыто STATE_CLOSED.

Создайте наследника AnimatingMenu, который добавляет третье состояние STATE_ANIMATING.

    При вызове open() состояние меняется на STATE_ANIMATING, а через 1 секунду, по таймеру, открытие завершается вызовом open() родителя.
    Вызов close() при необходимости отменяет таймер анимации (назначаемый в open) и передаёт вызов родительскому close.
    Метод showState для нового состояния выводит "анимация", для остальных – полагается на родителя.

### Решение:

function AnimatingMenu() {
      Menu.apply(this, arguments);
    }

    AnimatingMenu.prototype = Object.create(Menu.prototype);

    AnimatingMenu.prototype.STATE_ANIMATING = 2;

    AnimatingMenu.prototype.open = function() {
      var self = this;

      this._state = this.STATE_ANIMATING;

      this._timer = setTimeout(function() {
        Menu.prototype.open.call(self);
      }, 1000);
    };

    AnimatingMenu.prototype.close = function() {
      clearTimeout(this._timer);
      Menu.prototype.close.apply(this);
    };

    AnimatingMenu.prototype._stateAsString = function() {

      switch (this._state) {
        case this.STATE_ANIMATING:
          return 'анимация';

        default:
          return Menu.prototype._stateAsString.call(this);
      }
    };

    // тест, использование..
    var menu = new AnimatingMenu();

    menu.showState(); // закрыто

    menu.open();
    menu.showState(); // анимация

    setTimeout(function() { // через 1 секунду
      menu.showState(); // открыто

      menu.close();
      menu.showState(); // закрыто
    }, 1000);


17) В коде ниже создаётся простейшая иерархия классов: Animal -> Rabbit.

Что содержит свойство rabbit.constructor? Распознает ли проверка в alert объект как Rabbit?

function Animal() {}

function Rabbit() {}
Rabbit.prototype = Object.create(Animal.prototype);

var rabbit = new Rabbit();

alert( rabbit.constructor == Rabbit ); // что выведет?

### Решение:

Нет, не распознает, выведет false.

Свойство constructor содержится в prototype функции по умолчанию, интерпретатор не поддерживает его корректность. Посмотрим, чему оно равно и откуда оно будет взято в данном случае.

Порядок поиска свойства rabbit.constructor, по цепочке прототипов:

    rabbit – это пустой объект, в нём нет.
    Rabbit.prototype – в него при помощи Object.create записан пустой объект, наследующий от Animal.prototype. Поэтому constructor'а в нём также нет.
    Animal.prototype – у функции Animal свойство prototype никто не менял. Поэтому оно содержит Animal.prototype.constructor == Animal.

18) Почему instanceof в коде ниже возвращает true, ведь объект a явно создан не B()?

function A() {}

function B() {}

A.prototype = B.prototype = {};

var a = new A();

alert( a instanceof B ); // true


### Решение:

Да, это выглядит достаточно странно, поскольку объект a не создавался функцией B.

Но методу instanceof на самом деле вообще не важна функция. Он смотрит на её prototype и сверяет его с цепочкой __proto__ объекта.

В данном случае a.__proto__ == B.prototype, поэтому instanceof возвращает true.

По логике instanceof именно прототип задаёт «тип объекта», поэтому instanceof работает именно так.

19) В коде ниже создаётся простейшая иерархия классов: Animal -> Rabbit.

Что выведет instanceof?

Распознает ли он rabbit как Animal, Rabbit и к тому же Object?


function Animal() {}
function Rabbit() {}
Rabbit.prototype = Object.create(Animal.prototype);
var rabbit = new Rabbit();
alert( rabbit instanceof Rabbit );
alert( rabbit instanceof Animal );
alert( rabbit instanceof Object );


### Решение:

Да, распознает.

Он проверяет наследование с учётом цепочки прототипов.

function Animal() {}

function Rabbit() {}
Rabbit.prototype = Object.create(Animal.prototype);

var rabbit = new Rabbit();

alert( rabbit instanceof Rabbit ); // true
alert( rabbit instanceof Animal ); // true
alert( rabbit instanceof Object ); // true

20)Создайте ошибку FormatError, которая будет наследовать от встроенного класса SyntaxError.

Синтаксис для её создания – такой же, как обычно:

var err = new FormatError("ошибка форматирования");

alert( err.message ); // ошибка форматирования
alert( err.name ); // FormatError
alert( err.stack ); // стек на момент генерации ошибки

alert( err instanceof SyntaxError ); // true


### Решение:

function FormatError(message) {
  this.name = "FormatError";

  this.message = message;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

}

FormatError.prototype = Object.create(SyntaxError.prototype);
FormatError.prototype.constructor = FormatError;

// Использование

var err = new FormatError("ошибка форматирования");

alert( err.message ); // ошибка форматирования
alert( err.name ); // FormatError
alert( err.stack ); // стек на момент генерации ошибки

alert( err instanceof SyntaxError ); // true